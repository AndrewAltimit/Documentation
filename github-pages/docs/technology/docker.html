<h1 id="containers">Containers</h1>

<html><header><link rel="stylesheet" href="https://andrewaltimit.github.io/Documentation/style.css" /></header></html>

<div class="hero-section">
  <div class="hero-content">
    <h1 class="hero-title">Containers &amp; Docker</h1>
    <p class="hero-subtitle">Build, Ship, and Run Anywhere</p>
  </div>
</div>

<div class="intro-card">
  <p class="lead-text">Containers provide a consistent environment for applications by packaging software, dependencies, and configurations into a single, portable unit. However, there are some cases where this consistency might be compromised, particularly when dealing with kernel differences.</p>
  
  <div class="key-insights">
    <div class="insight-card">
      <i class="fas fa-box"></i>
      <h4>Lightweight</h4>
      <p>Share host OS kernel</p>
    </div>
    <div class="insight-card">
      <i class="fas fa-rocket"></i>
      <h4>Fast Startup</h4>
      <p>Seconds vs minutes</p>
    </div>
    <div class="insight-card">
      <i class="fas fa-globe"></i>
      <h4>Portable</h4>
      <p>Run anywhere consistently</p>
    </div>
  </div>
</div>

<h2 id="containers-vs-virtual-machines">Containers vs Virtual Machines</h2>

<div class="comparison-section">
  <p class="section-intro">Containers are lightweight, resource-efficient, and portable, making them suitable for modern, scalable applications. Virtual machines provide strong isolation, full OS support, and hardware emulation but can be resource-intensive and slower to start up.</p>
  
  <div class="architecture-comparison">
    <div class="architecture-diagram">
      <svg viewBox="0 0 600 350">
        <!-- Container Architecture -->
        <g id="container-arch">
          <text x="150" y="20" text-anchor="middle" font-size="14" font-weight="bold">Container Architecture</text>
          
          <!-- Hardware -->
          <rect x="50" y="300" width="200" height="40" fill="#34495e" />
          <text x="150" y="325" text-anchor="middle" font-size="11" fill="white">Hardware</text>
          
          <!-- Host OS -->
          <rect x="50" y="250" width="200" height="40" fill="#3498db" />
          <text x="150" y="275" text-anchor="middle" font-size="11" fill="white">Host OS + Kernel</text>
          
          <!-- Container Runtime -->
          <rect x="50" y="200" width="200" height="40" fill="#e74c3c" />
          <text x="150" y="225" text-anchor="middle" font-size="11" fill="white">Container Runtime</text>
          
          <!-- Containers -->
          <rect x="60" y="80" width="55" height="110" fill="#2ecc71" opacity="0.7" stroke="#27ae60" stroke-width="2" />
          <text x="87" y="100" text-anchor="middle" font-size="9" fill="white">App A</text>
          <text x="87" y="115" text-anchor="middle" font-size="8" fill="white">Bins/Libs</text>
          
          <rect x="125" y="80" width="55" height="110" fill="#f39c12" opacity="0.7" stroke="#d68910" stroke-width="2" />
          <text x="152" y="100" text-anchor="middle" font-size="9" fill="white">App B</text>
          <text x="152" y="115" text-anchor="middle" font-size="8" fill="white">Bins/Libs</text>
          
          <rect x="190" y="80" width="55" height="110" fill="#9b59b6" opacity="0.7" stroke="#8e44ad" stroke-width="2" />
          <text x="217" y="100" text-anchor="middle" font-size="9" fill="white">App C</text>
          <text x="217" y="115" text-anchor="middle" font-size="8" fill="white">Bins/Libs</text>
        </g>
        
        <!-- VM Architecture -->
        <g id="vm-arch" transform="translate(300,0)">
          <text x="150" y="20" text-anchor="middle" font-size="14" font-weight="bold">Virtual Machine Architecture</text>
          
          <!-- Hardware -->
          <rect x="50" y="300" width="200" height="40" fill="#34495e" />
          <text x="150" y="325" text-anchor="middle" font-size="11" fill="white">Hardware</text>
          
          <!-- Host OS -->
          <rect x="50" y="250" width="200" height="40" fill="#3498db" />
          <text x="150" y="275" text-anchor="middle" font-size="11" fill="white">Host OS</text>
          
          <!-- Hypervisor -->
          <rect x="50" y="200" width="200" height="40" fill="#e74c3c" />
          <text x="150" y="225" text-anchor="middle" font-size="11" fill="white">Hypervisor</text>
          
          <!-- VMs -->
          <rect x="60" y="50" width="55" height="140" fill="#2ecc71" opacity="0.7" stroke="#27ae60" stroke-width="2" />
          <text x="87" y="70" text-anchor="middle" font-size="9" fill="white">App A</text>
          <text x="87" y="85" text-anchor="middle" font-size="8" fill="white">Bins/Libs</text>
          <rect x="65" y="120" width="45" height="25" fill="#27ae60" opacity="0.5" />
          <text x="87" y="137" text-anchor="middle" font-size="8" fill="white">Guest OS</text>
          
          <rect x="125" y="50" width="55" height="140" fill="#f39c12" opacity="0.7" stroke="#d68910" stroke-width="2" />
          <text x="152" y="70" text-anchor="middle" font-size="9" fill="white">App B</text>
          <text x="152" y="85" text-anchor="middle" font-size="8" fill="white">Bins/Libs</text>
          <rect x="130" y="120" width="45" height="25" fill="#d68910" opacity="0.5" />
          <text x="152" y="137" text-anchor="middle" font-size="8" fill="white">Guest OS</text>
          
          <rect x="190" y="50" width="55" height="140" fill="#9b59b6" opacity="0.7" stroke="#8e44ad" stroke-width="2" />
          <text x="217" y="70" text-anchor="middle" font-size="9" fill="white">App C</text>
          <text x="217" y="85" text-anchor="middle" font-size="8" fill="white">Bins/Libs</text>
          <rect x="195" y="120" width="45" height="25" fill="#8e44ad" opacity="0.5" />
          <text x="217" y="137" text-anchor="middle" font-size="8" fill="white">Guest OS</text>
        </g>
      </svg>
    </div>
  </div>
</div>

<div class="pros-cons-comparison">
  <div class="container-pros-cons">
    <h3><i class="fas fa-box"></i> Container Pros/Cons</h3>
    
    <div class="pros-cons-grid">
      <div class="pros-section">
        <h4><i class="fas fa-check-circle"></i> Pros</h4>
        <div class="pro-item">
          <i class="fas fa-feather-alt"></i>
          <div>
            <strong>Lightweight</strong>
            <p>Share the host OS kernel, minimal overhead</p>
          </div>
        </div>
        <div class="pro-item">
          <i class="fas fa-rocket"></i>
          <div>
            <strong>Fast startup</strong>
            <p>Start in seconds for rapid deployment</p>
          </div>
        </div>
        <div class="pro-item">
          <i class="fas fa-chart-line"></i>
          <div>
            <strong>Resource efficiency</strong>
            <p>Higher density on single host</p>
          </div>
        </div>
        <div class="pro-item">
          <i class="fas fa-ship"></i>
          <div>
            <strong>Portability</strong>
            <p>Consistent deployment across environments</p>
          </div>
        </div>
        <div class="pro-item">
          <i class="fas fa-shield-alt"></i>
          <div>
            <strong>Process Isolation</strong>
            <p>Applications run without interference</p>
          </div>
        </div>
      </div>
      
      <div class="cons-section">
        <h4><i class="fas fa-times-circle"></i> Cons</h4>
        <div class="con-item">
          <i class="fas fa-link"></i>
          <div>
            <strong>Kernel dependency</strong>
            <p>Limited cross-platform compatibility</p>
          </div>
        </div>
        <div class="con-item">
          <i class="fas fa-lock-open"></i>
          <div>
            <strong>Security boundaries</strong>
            <p>Weaker isolation than VMs</p>
          </div>
        </div>
        <div class="con-item">
          <i class="fas fa-ban"></i>
          <div>
            <strong>Limited applications</strong>
            <p>Not suitable for kernel modifications</p>
          </div>
        </div>
      </div>
    </div>
  </div>

  <div class="vm-pros-cons">
    <h3><i class="fas fa-desktop"></i> Virtual Machine Pros/Cons</h3>
    
    <div class="pros-cons-grid">
      <div class="pros-section">
        <h4><i class="fas fa-check-circle"></i> Pros</h4>
        <div class="pro-item">
          <i class="fas fa-lock"></i>
          <div>
            <strong>Strong isolation</strong>
            <p>Complete OS separation for security</p>
          </div>
        </div>
        <div class="pro-item">
          <i class="fas fa-layer-group"></i>
          <div>
            <strong>Full OS support</strong>
            <p>Run any OS version or distribution</p>
          </div>
        </div>
        <div class="pro-item">
          <i class="fas fa-microchip"></i>
          <div>
            <strong>Hardware emulation</strong>
            <p>Support legacy and platform-specific apps</p>
          </div>
        </div>
        <div class="pro-item">
          <i class="fas fa-history"></i>
          <div>
            <strong>Mature ecosystem</strong>
            <p>Extensive tooling and management</p>
          </div>
        </div>
      </div>
      
      <div class="cons-section">
        <h4><i class="fas fa-times-circle"></i> Cons</h4>
        <div class="con-item">
          <i class="fas fa-weight-hanging"></i>
          <div>
            <strong>Resource-intensive</strong>
            <p>Full OS stack overhead</p>
          </div>
        </div>
        <div class="con-item">
          <i class="fas fa-hourglass-half"></i>
          <div>
            <strong>Slow startup</strong>
            <p>Minutes to boot and initialize</p>
          </div>
        </div>
        <div class="con-item">
          <i class="fas fa-database"></i>
          <div>
            <strong>Storage overhead</strong>
            <p>Duplicated OS and libraries</p>
          </div>
        </div>
        <div class="con-item">
          <i class="fas fa-random"></i>
          <div>
            <strong>Deployment complexity</strong>
            <p>Manual dependency management</p>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<h3 id="container-consistency">Container Consistency</h3>

<ul>
  <li><strong>Application dependencies:</strong> Containers bundle all required libraries and dependencies, ensuring that the application runs consistently across different environments.</li>
  <li><strong>Configuration:</strong> Containers encapsulate the application’s configuration, making it easy to reproduce and share across teams and environments.</li>
  <li><strong>Isolation:</strong> Containers provide process isolation, so applications running in separate containers won’t interfere with one another.</li>
  <li><strong>Portability:</strong> Containers can run on any system with container runtime support, regardless of the host’s underlying hardware or operating system.</li>
</ul>

<h3 id="container-inconsistency">Container Inconsistency</h3>

<ul>
  <li><strong>Kernel differences:</strong> Containers share the host’s kernel, which means that they are susceptible to inconsistencies stemming from kernel differences. For example, a container running on a host with an older kernel version may not have access to newer kernel features. Additionally, certain system calls or kernel modules may not be available or compatible across different host systems.</li>
  <li><strong>Host-specific resources:</strong> Containers can access host resources like filesystems, devices, and network interfaces. However, these resources may not be consistent across different host systems, leading to potential inconsistencies in container behavior.</li>
  <li><strong>Resource limits and constraints:</strong> Containers can be limited in terms of resources, such as CPU, memory, or I/O. These limits may vary between host systems and can impact the consistency of container performance.</li>
  <li><strong>Platform-specific features:</strong> Some features, such as hardware acceleration, are platform-specific and may not be consistently available across different host systems. As a result, containers relying on these features may experience inconsistent behavior.</li>
</ul>

<p>While containers provide a high level of consistency for application dependencies, configuration, isolation, and portability, they can be susceptible to inconsistencies due to kernel differences, host-specific resources, resource limits, and platform-specific features. To minimize these inconsistencies, it is essential to understand the requirements of your application and ensure that the host systems are compatible with the desired container environment.</p>

<h1 id="docker-architecture-deep-dive">Docker Architecture Deep Dive</h1>

<h2 id="container-runtime-architecture">Container Runtime Architecture</h2>

<p>Docker uses a layered architecture to manage containers:</p>

<h3 id="oci-open-container-initiative-runtime">OCI (Open Container Initiative) Runtime</h3>

<p>The low-level container runtime follows the OCI specification:</p>

<p><strong>Key Components</strong>:</p>
<ul>
  <li><strong>OCI Bundle</strong>: Directory with <code class="language-plaintext highlighter-rouge">config.json</code> and <code class="language-plaintext highlighter-rouge">rootfs/</code></li>
  <li><strong>Runtime Spec</strong>: JSON configuration defining container properties</li>
  <li><strong>Lifecycle</strong>: Create, start, kill, delete operations</li>
</ul>

<p><strong>Container Configuration</strong>:</p>
<ul>
  <li><strong>Process</strong>: Command, environment, working directory, capabilities</li>
  <li><strong>Root Filesystem</strong>: Mount points and readonly settings</li>
  <li><strong>Namespaces</strong>: PID, Network, IPC, UTS, Mount, User, Cgroup isolation</li>
  <li><strong>Resources</strong>: Memory, CPU, PID limits, block I/O controls</li>
  <li><strong>Security</strong>: Seccomp profiles, masked paths, readonly paths</li>
</ul>

<p><strong>Resource Management</strong>:</p>
<ul>
  <li>Memory limits and reservations</li>
  <li>CPU shares, quotas, and cpuset assignment</li>
  <li>Process ID limits</li>
  <li>Block I/O weight and throttling</li>
  <li>Network class IDs and priorities</li>
</ul>

<h3 id="containerd-integration">Containerd Integration</h3>

<p>High-level container management daemon:</p>

<p><strong>Architecture</strong>:</p>
<ul>
  <li><strong>gRPC API</strong>: Remote procedure calls for container operations</li>
  <li><strong>Namespaces</strong>: Logical grouping of containers and images</li>
  <li><strong>Snapshots</strong>: Filesystem snapshots for container rootfs</li>
  <li><strong>Content Store</strong>: Storage for image layers and manifests</li>
</ul>

<p><strong>Key Operations</strong>:</p>
<ul>
  <li>Pull images from registries</li>
  <li>Create containers from images</li>
  <li>Manage container lifecycle (start, stop, pause, resume)</li>
  <li>Execute commands in running containers</li>
  <li>Stream logs and attach to containers</li>
</ul>

<blockquote>
  <p><strong>Code Reference</strong>: For complete implementation of OCI runtime and containerd integration, see:</p>
  <ul>
    <li><a href="../../code-examples/technology/docker/container_runtime.py"><code class="language-plaintext highlighter-rouge">container_runtime.py</code></a> - OCI runtime implementation</li>
    <li><a href="../../code-examples/technology/docker/containerd_integration.py"><code class="language-plaintext highlighter-rouge">containerd_integration.py</code></a> - Containerd client</li>
  </ul>
</blockquote>

<h2 id="docker-network-architecture">Docker Network Architecture</h2>

<h3 id="container-network-interface-cni">Container Network Interface (CNI)</h3>

<p>Standard for container networking plugins:</p>

<p><strong>CNI Specification</strong>:</p>
<ul>
  <li><strong>ADD</strong>: Connect container to network</li>
  <li><strong>DEL</strong>: Disconnect container from network</li>
  <li><strong>CHECK</strong>: Verify container connectivity</li>
  <li><strong>VERSION</strong>: Report plugin version</li>
</ul>

<p><strong>Network Configuration</strong>:</p>
<ul>
  <li>Create veth (virtual ethernet) pairs</li>
  <li>Configure network namespaces</li>
  <li>Assign IP addresses and routes</li>
  <li>Setup DNS configuration</li>
</ul>

<h3 id="docker-bridge-network-driver">Docker Bridge Network Driver</h3>

<p>Default network driver for containers:</p>

<p><strong>Components</strong>:</p>
<ul>
  <li><strong>Linux Bridge</strong>: Virtual switch for container communication</li>
  <li><strong>veth Pairs</strong>: Virtual cable connecting container to bridge</li>
  <li><strong>iptables Rules</strong>: NAT and packet filtering</li>
  <li><strong>IP Address Management</strong>: Allocation and tracking</li>
</ul>

<p><strong>Network Isolation</strong>:</p>
<ul>
  <li>Network namespaces per container</li>
  <li>Bridge isolation between networks</li>
  <li>ICC (Inter-Container Communication) control</li>
  <li>Port mapping and exposure</li>
</ul>

<h3 id="ip-address-management-ipam">IP Address Management (IPAM)</h3>

<p>Manages IP allocation for containers:</p>

<p><strong>Features</strong>:</p>
<ul>
  <li>Subnet management</li>
  <li>Dynamic IP allocation</li>
  <li>Address release and reuse</li>
  <li>Conflict prevention</li>
  <li>Gateway reservation</li>
</ul>

<blockquote>
  <p><strong>Code Reference</strong>: For complete networking implementation, see <a href="../../code-examples/technology/docker/container_networking.py"><code class="language-plaintext highlighter-rouge">container_networking.py</code></a></p>
</blockquote>

<h1 id="docker">Docker</h1>

<div class="docker-section">
  <div class="docker-intro">
    <p>Docker is a platform for developing, shipping, and running applications via containerization technology which packages applications and their dependencies into lightweight and portable containers that can run consistently across different environments.</p>
    
    <div class="docker-workflow">
      <h3><i class="fas fa-cogs"></i> Docker Workflow</h3>
      <svg viewBox="0 0 700 200" class="workflow-diagram">
        <!-- Build Stage -->
        <rect x="50" y="50" width="120" height="100" fill="#3498db" opacity="0.3" stroke="#2980b9" stroke-width="2" />
        <text x="110" y="80" text-anchor="middle" font-size="14" font-weight="bold">BUILD</text>
        <rect x="70" y="95" width="80" height="40" fill="#2c3e50" />
        <text x="110" y="120" text-anchor="middle" font-size="10" fill="white">Dockerfile</text>
        
        <!-- Arrow -->
        <path d="M 175 100 L 225 100" stroke="#34495e" stroke-width="3" marker-end="url(#arrow)" />
        <text x="200" y="90" text-anchor="middle" font-size="10">docker build</text>
        
        <!-- Ship Stage -->
        <rect x="230" y="50" width="120" height="100" fill="#e74c3c" opacity="0.3" stroke="#c0392b" stroke-width="2" />
        <text x="290" y="80" text-anchor="middle" font-size="14" font-weight="bold">SHIP</text>
        <circle cx="290" cy="110" r="25" fill="#c0392b" />
        <text x="290" y="115" text-anchor="middle" font-size="10" fill="white">Image</text>
        
        <!-- Registry -->
        <rect x="380" y="30" width="140" height="140" fill="#f39c12" opacity="0.2" stroke="#d68910" stroke-width="2" />
        <text x="450" y="55" text-anchor="middle" font-size="12">Docker Registry</text>
        <rect x="400" y="70" width="40" height="30" fill="#d68910" opacity="0.5" />
        <rect x="450" y="70" width="40" height="30" fill="#d68910" opacity="0.5" />
        <rect x="400" y="110" width="40" height="30" fill="#d68910" opacity="0.5" />
        <rect x="450" y="110" width="40" height="30" fill="#d68910" opacity="0.5" />
        
        <!-- Push arrow -->
        <path d="M 315 100 Q 350 80, 375 100" stroke="#34495e" stroke-width="2" marker-end="url(#arrow)" />
        <text x="345" y="75" text-anchor="middle" font-size="9">push</text>
        
        <!-- Pull arrow -->
        <path d="M 520 100 Q 545 120, 545 150" stroke="#34495e" stroke-width="2" marker-end="url(#arrow)" />
        <text x="535" y="125" text-anchor="middle" font-size="9">pull</text>
        
        <!-- Run Stage -->
        <rect x="480" y="155" width="120" height="40" fill="#27ae60" opacity="0.3" stroke="#229954" stroke-width="2" />
        <text x="540" y="180" text-anchor="middle" font-size="14" font-weight="bold">RUN</text>
        <text x="620" y="175" font-size="10">Containers</text>
      </svg>
    </div>
  </div>
</div>

<h2 id="installing-docker">Installing Docker</h2>

<ul>
  <li><a href="https://docs.docker.com/engine/install/ubuntu/">Install Docker on Ubuntu</a></li>
  <li><a href="https://docs.docker.com/engine/install/debian/">Install Docker on Debian</a></li>
  <li><a href="https://docs.docker.com/engine/install/fedora/">Install Docker on Fedora</a></li>
  <li><a href="https://docs.docker.com/engine/install/centos/">Install Docker on CentOS</a></li>
  <li><a href="https://docs.docker.com/docker-for-windows/install/">Install Docker on Windows</a></li>
  <li><a href="https://docs.docker.com/docker-for-mac/install/">Install Docker on macOS</a></li>
</ul>

<h2 id="common-docker-cli-commands">Common Docker CLI Commands</h2>

<div class="docker-commands">
  <div class="command-category">
    <h3><i class="fas fa-images"></i> Images</h3>
    <div class="command-grid">
      <div class="command-item">
        <code>docker images</code>
        <span>List all local images</span>
      </div>
      <div class="command-item">
        <code>docker pull &lt;image&gt;:&lt;tag&gt;</code>
        <span>Download image from registry</span>
      </div>
      <div class="command-item">
        <code>docker rmi &lt;image&gt;:&lt;tag&gt;</code>
        <span>Remove an image</span>
      </div>
    </div>
  </div>
  
  <div class="command-category">
    <h3><i class="fas fa-cube"></i> Containers</h3>
    <div class="command-grid">
      <div class="command-item">
        <code>docker ps</code>
        <span>List running containers</span>
      </div>
      <div class="command-item">
        <code>docker ps -a</code>
        <span>List all containers</span>
      </div>
      <div class="command-item">
        <code>docker run -it --rm --name &lt;name&gt; &lt;image&gt;:&lt;tag&gt;</code>
        <span>Run interactive container</span>
      </div>
      <div class="command-item">
        <code>docker stop &lt;container&gt;</code>
        <span>Stop a running container</span>
      </div>
      <div class="command-item">
        <code>docker rm &lt;container&gt;</code>
        <span>Remove a container</span>
      </div>
    </div>
  </div>
  
  <div class="command-category">
    <h3><i class="fas fa-file-alt"></i> Container Operations</h3>
    <div class="command-grid">
      <div class="command-item">
        <code>docker logs &lt;container&gt;</code>
        <span>View container logs</span>
      </div>
      <div class="command-item">
        <code>docker exec -it &lt;container&gt; &lt;command&gt;</code>
        <span>Execute command in container</span>
      </div>
    </div>
  </div>
  
  <div class="command-category">
    <h3><i class="fas fa-hammer"></i> Building &amp; Publishing</h3>
    <div class="command-grid">
      <div class="command-item">
        <code>docker build -t &lt;image&gt;:&lt;tag&gt; .</code>
        <span>Build image from Dockerfile</span>
      </div>
      <div class="command-item">
        <code>docker push &lt;image&gt;:&lt;tag&gt;</code>
        <span>Push image to registry</span>
      </div>
    </div>
  </div>
  
  <div class="command-flow">
    <h3><i class="fas fa-stream"></i> Common Workflow</h3>
    <div class="workflow-steps">
      <div class="workflow-step">
        <div class="step-number">1</div>
        <code>docker build -t myapp:1.0 .</code>
        <span>Build your application image</span>
      </div>
      <div class="workflow-step">
        <div class="step-number">2</div>
        <code>docker run -d -p 8080:80 myapp:1.0</code>
        <span>Run container in detached mode</span>
      </div>
      <div class="workflow-step">
        <div class="step-number">3</div>
        <code>docker logs -f &lt;container_id&gt;</code>
        <span>Monitor application logs</span>
      </div>
      <div class="workflow-step">
        <div class="step-number">4</div>
        <code>docker push myapp:1.0</code>
        <span>Share image via registry</span>
      </div>
    </div>
  </div>
</div>

<h3 id="docker-compose">Docker Compose</h3>

<ul>
  <li>Start a multi-container application: <code class="language-plaintext highlighter-rouge">docker-compose up -d</code></li>
  <li>Stop a multi-container application: <code class="language-plaintext highlighter-rouge">docker-compose down</code></li>
</ul>

<h3 id="docker-volumes">Docker Volumes</h3>

<ul>
  <li>Create a volume: <code class="language-plaintext highlighter-rouge">docker volume create &lt;volume_name&gt;</code></li>
  <li>List volumes: <code class="language-plaintext highlighter-rouge">docker volume ls</code></li>
  <li>Remove a volume: <code class="language-plaintext highlighter-rouge">docker volume rm &lt;volume_name&gt;</code></li>
</ul>

<h2 id="writing-dockerfiles">Writing Dockerfiles</h2>

<p>A Dockerfile is a script containing instructions to build a Docker image. It automates the process of creating a container by specifying the base image, configuration, application code, and dependencies. This documentation will cover the basics of writing a Dockerfile, its syntax, and using multistage builds.</p>

<h3 id="dockerfile-example">Dockerfile Example</h3>

<p>A Dockerfile consists of a series of instructions, each starting with an uppercase keyword followed by arguments. The instructions are executed in the order they appear, and each instruction creates a new layer in the Docker image. Comments can be added using the # symbol.</p>

<p>Here’s a simple example:</p>

<div class="language-dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Use an official Python runtime as a parent image</span>
<span class="k">FROM</span><span class="s"> python:3.8-slim</span>

<span class="c"># Set the working directory to /app</span>
<span class="k">WORKDIR</span><span class="s"> /app</span>

<span class="c"># Copy the current directory contents into the container at /app</span>
<span class="k">COPY</span><span class="s"> . /app</span>

<span class="c"># Install any needed packages specified in requirements.txt</span>
<span class="k">RUN </span>pip <span class="nb">install</span> <span class="nt">--trusted-host</span> pypi.python.org <span class="nt">-r</span> requirements.txt

<span class="c"># Make port 80 available to the world outside this container</span>
<span class="k">EXPOSE</span><span class="s"> 80</span>

<span class="c"># Define environment variable</span>
<span class="k">ENV</span><span class="s"> NAME World</span>

<span class="c"># Run app.py when the container launches</span>
<span class="k">CMD</span><span class="s"> ["python", "app.py"]</span>
</code></pre></div></div>

<h3 id="dockerfile-instructions">Dockerfile Instructions</h3>

<h4 id="from">FROM</h4>

<p>The <strong>FROM</strong> instruction sets the base image for your Dockerfile. It must be the first instruction in the file. You can use an official image from the Docker Hub or a custom image.</p>

<div class="language-dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">FROM</span><span class="s"> &lt;image&gt;[:&lt;tag&gt;] [AS &lt;name&gt;]</span>
</code></pre></div></div>

<h4 id="workdir">WORKDIR</h4>

<p>The <strong>WORKDIR</strong> instruction sets the working directory for any subsequent <strong>RUN</strong>, <strong>CMD</strong>, <strong>ENTRYPOINT</strong>, <strong>COPY</strong>, and <strong>ADD</strong> instructions. If the directory does not exist, it will be created.</p>

<div class="language-dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">WORKDIR</span><span class="s"> &lt;path&gt;</span>
</code></pre></div></div>

<h4 id="copy">COPY</h4>

<p>The <strong>COPY</strong> instruction copies files or directories from the local filesystem to the container’s filesystem.</p>

<div class="language-dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">COPY</span><span class="s"> &lt;src&gt; &lt;dest&gt;</span>
</code></pre></div></div>

<h4 id="add">ADD</h4>

<p>The <strong>ADD</strong> instruction is similar to <strong>COPY</strong>, but it can also download remote files and extract compressed files.</p>

<div class="language-dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">ADD</span><span class="s"> &lt;src&gt; &lt;dest&gt;</span>
</code></pre></div></div>

<h4 id="run">RUN</h4>

<p>The <strong>RUN</strong> instruction executes a command during the build process, creating a new layer.</p>

<div class="language-dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">RUN </span>&lt;<span class="nb">command</span><span class="o">&gt;</span>
</code></pre></div></div>

<h4 id="cmd">CMD</h4>

<p>The <strong>CMD</strong> instruction provides the default command that will be executed when running a container.</p>

<div class="language-dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CMD</span><span class="s"> ["executable", "param1", "param2"]</span>
</code></pre></div></div>

<h4 id="entrypoint">ENTRYPOINT</h4>

<p>The <strong>ENTRYPOINT</strong> instruction allows you to configure a container that will run as an executable.</p>

<div class="language-dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">ENTRYPOINT</span><span class="s"> ["executable", "param1", "param2"]</span>
</code></pre></div></div>

<h4 id="expose">EXPOSE</h4>

<p>The <strong>EXPOSE</strong> instruction informs Docker that the container listens on the specified network ports at runtime.</p>

<div class="language-dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">EXPOSE</span><span class="s"> &lt;port&gt; [&lt;port&gt;/&lt;protocol&gt;...]</span>
</code></pre></div></div>

<h4 id="env">ENV</h4>

<p>The <strong>ENV</strong> instruction sets an environment variable.</p>

<div class="language-dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">ENV</span><span class="s"> &lt;key&gt;=&lt;value&gt; ...</span>
</code></pre></div></div>

<h4 id="arg">ARG</h4>

<p>The <strong>ARG</strong> instruction defines a variable that can be passed to the build process using the <code class="language-plaintext highlighter-rouge">--build-arg</code> flag.</p>

<div class="language-dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">ARG</span><span class="s"> &lt;name&gt;[=&lt;default value&gt;]</span>
</code></pre></div></div>

<h3 id="multistage-builds">Multistage Builds</h3>

<p>Multistage builds allow you to optimize the Dockerfile by using multiple FROM instructions, each with a unique name. This is useful when you need to use multiple images or want to reduce the final image size.</p>

<p>Here’s an example:</p>

<div class="language-dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Stage 1: Build the application</span>
<span class="k">FROM</span><span class="w"> </span><span class="s">node:14</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="s">build</span>
<span class="k">WORKDIR</span><span class="s"> /app</span>
<span class="k">COPY</span><span class="s"> package*.json ./</span>
<span class="k">RUN </span>npm <span class="nb">install</span>
<span class="k">COPY</span><span class="s"> . .</span>
<span class="k">RUN </span>npm run build

<span class="c"># Stage 2: Create the final image</span>
<span class="k">FROM</span><span class="s"> nginx:1.19-alpine</span>
<span class="k">COPY</span><span class="s"> --from=build /app/build /usr/share/nginx/html</span>
<span class="k">EXPOSE</span><span class="s"> 80</span>
<span class="k">CMD</span><span class="s"> ["nginx", "-g", "daemon off;"]</span>
</code></pre></div></div>

<p>In this example, the first stage uses the node:14 image to build the application, and the second stage uses the nginx:1.19-alpine image to serve the application. The <code class="language-plaintext highlighter-rouge">COPY --from=build</code> command copies the built application files from the first stage to the final image. This results in a smaller final image without the build dependencies.</p>

<h2 id="best-practices">Best Practices</h2>

<ul>
  <li>Use official base images: Official images are maintained and optimized by the creators of the respective software.</li>
  <li>Be specific with base image tags: Specify an exact version or use a specific tag to avoid breaking changes in the future.</li>
  <li>Keep layers to a minimum: Group related commands together and use a single RUN instruction whenever possible.</li>
  <li>Use .dockerignore file: Exclude unnecessary files from the build context to reduce build time and prevent sensitive data from being included in the image.</li>
  <li>Cache dependencies: Copy dependency files separately from the application code to take advantage of Docker’s build cache and avoid unnecessary re-installations.</li>
  <li>Use multi-stage builds: Multi-stage builds can help reduce the final image size by only including the necessary files for the runtime environment.</li>
</ul>
